<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Ultra-Fast Scanner — 1D + QR (v2.2 iOS-safe + Always-visible send)</title>

  <!-- Анти-кеш для WebView -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>

  <!-- Telegram WebApp SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <!-- ZXing UMD (core) -->
  <script src="https://unpkg.com/@zxing/library@0.20.0/umd/index.min.js"></script>

  <style>
    :root { color-scheme: dark }
    html,body{height:100%}
    body{margin:0;background:#000;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #stage{position:fixed;inset:0;overflow:hidden;background:#000;padding-bottom:84px} /* місце для панелі внизу */
    #video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
    #mask{position:absolute;inset:0;pointer-events:none;display:grid;place-items:center}
    #roi{width:min(86vw,680px);height:min(40vh,340px);outline:2px solid rgba(255,255,255,.9);border-radius:18px;box-shadow:0 0 0 200vmax rgba(0,0,0,.55) inset}
    #tag{position:absolute;left:12px;bottom:96px;font-size:12px;opacity:.85;background:#111;border:1px solid #2c2c2c;border-radius:999px;padding:4px 10px}
    #status{position:absolute;top:12px;left:12px;right:12px;font-size:13px;background:#111;border:1px solid #2c2c2c;border-radius:10px;padding:6px 10px;max-width:100%}
    #canvas{display:none}
    #log{position:absolute;right:12px;bottom:152px;width:min(92vw,560px);max-height:42vh;overflow:auto;background:#0b0b0b;opacity:.92;border:1px solid #2a2a2a;border-radius:12px;padding:8px;font:12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}

    /* Постійна нижня панель з інпутом і кнопкою */
    #bottomBar{
      position:fixed;left:0;right:0;bottom:0;height:84px;display:flex;gap:10px;align-items:center;
      padding:12px; background:linear-gradient(180deg, rgba(0,0,0,.3), rgba(0,0,0,.9));
      border-top:1px solid #2a2a2a; z-index:2147483647; box-shadow:0 -8px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(4px);
    }
    #manualInput{
      flex:1; height:48px; border-radius:12px; border:1px solid #2c2c2c; background:#111; color:#fff;
      padding:0 12px; font-size:16px;
    }
    #fallbackBtn{
      height:48px;border-radius:12px;background:#00a884;color:#fff;border:none;font-weight:700;font-size:16px;
      padding:0 16px; cursor:pointer; white-space:nowrap;
    }
    #fallbackBtn[disabled]{opacity:.5;cursor:not-allowed}
    .hint{position:absolute;left:12px;bottom:12px;font-size:11px;opacity:.7}
  </style>
</head>
<body>
  <main id="stage">
    <video id="video" playsinline webkit-playsinline autoplay muted></video>
    <div id="mask"><div id="roi"></div></div>
    <div id="status">Ініціалізація…</div>
    <div id="tag">Ultra-Fast Scanner v2.2</div>
    <pre id="log"></pre>
    <canvas id="canvas"></canvas>
  </main>

  <!-- Завжди видима панель -->
  <div id="bottomBar">
    <input id="manualInput" placeholder="Код (введіть або відскануйте)"/>
    <button id="fallbackBtn" disabled>Надіслати</button>
    <div class="hint" id="envHint"></div>
  </div>

  <script>
    const VERSION = '2.2';
    const SCAN_INTERVAL_MS = 110;
    const VIBRATE_MS = 20;
    const ALWAYS_SHOW_FALLBACK = true; // ключ: завжди показуємо нижню панель, не залежно від TG

    const BARCODE_FORMATS_NATIVE = [
      'qr_code','code_39','code_93','code_128','ean_13','ean_8','upc_a','upc_e','itf','codabar','data_matrix','pdf417'
    ];

    const $ = s => document.querySelector(s);
    const status = m => { $('#status').textContent = m; log('STATUS', m); };
    function log(tag, msg){
      const el=$('#log');
      const line = `[${new Date().toLocaleTimeString()}] ${tag}: ${msg}`;
      console.log(line);
      el.textContent = (el.textContent+"\n"+line).slice(-8000);
    }

    // Анти-кеш
    (async()=>{
      try{
        if('serviceWorker' in navigator){
          for(const r of await navigator.serviceWorker.getRegistrations()){ await r.unregister(); log('CACHE','SW unregistered'); }
        }
        if('caches' in window){
          for(const k of await caches.keys()){ await caches.delete(k); log('CACHE',`cache deleted: ${k}`); }
        }
        localStorage.setItem('scanner_version', VERSION);
      }catch(e){ log('CACHE','skip '+(e.message||e)); }
    })();

    // TG WebApp
    function getTG(){
      try{
        const tg = window.Telegram?.WebApp || window.parent?.Telegram?.WebApp || window.opener?.Telegram?.WebApp;
        if (tg) {
          try { tg.ready?.(); } catch(_) {}
          try { tg.expand?.(); tg.MainButton?.enable?.(); tg.MainButton?.hide?.(); } catch(_) {} // ховаємо MainButton, ми завжди показуємо свою
          log('TG','detected YES | platform='+(tg.platform||'unknown')+' ver='+(tg.version||'?'));
          log('TG','initData.len=' + ((tg.initData||'').length||0) + ' user=' + (tg.initDataUnsafe?.user?.id || 'none'));
          return tg;
        }
      }catch(e){ log('TG','error '+(e.message||e)); }
      log('TG','detected NO'); return null;
    }
    let TG = null;

    // Антидубль + автозакриття (потрібно для авто-режиму)
    let lastSent = { value:'', at:0 };
    let autoCloseTimer = null;

    function shouldSend(v){
      const n=Date.now();
      if(v===lastSent.value && (n-lastSent.at)<6000) return false;
      lastSent={value:v,at:n}; return true;
    }

    // Завжди видима кнопка — логіка
    const input = $('#manualInput');
    const sendBtn = $('#fallbackBtn');
    const envHint = $('#envHint');

    function updateSendBtnState(){
      const hasValue = (input.value||'').trim().length>0;
      sendBtn.disabled = !hasValue;
    }
    input.addEventListener('input', updateSendBtnState);

    async function handleManualSend(val){
      const code = String((val ?? input.value) || '').trim();
      if(!code) return;
      const payload = JSON.stringify({action:'handleScan', code});
      log('SEND','BottomBar payload ' + payload);

      if (TG?.sendData) {
        // В WebApp шлемо у бот
        try { TG.HapticFeedback?.impactOccurred?.('light'); } catch(_){}
        TG.sendData(payload);
        status(`Надіслано в бот: ${code}`);
        // Автозакриття залишаємо на розсуд: закривати чи ні?
        // try{ TG.close?.(); }catch(_){}
      } else {
        // Поза WebApp — копіюємо у буфер
        try {
          await navigator.clipboard?.writeText(code);
          status('Код скопійовано — вставте в чат Telegram. Відкрийте цю сторінку через кнопку бота для автонадсилання.');
        } catch {
          status('Відкрийте цю сторінку через кнопку в Telegram-боті, щоб надіслати код автоматично.');
        }
      }
    }
    sendBtn.addEventListener('click', ()=>handleManualSend());

    // Надсилання після скану (авто), але наша нижня кнопка видима завжди
    async function sendToBotAuto(code){
      try{
        if(!shouldSend(code)) return;
        navigator.vibrate?.(VIBRATE_MS);
        status(`Знайдено: ${code}`);

        // Підставляємо знайдене значення в інпут — користувач бачить і може вручну надіслати повторно
        input.value = code;
        updateSendBtnState();

        TG = TG || getTG();
        if (TG) {
          // Автовідправка в WebApp
          setTimeout(()=>{
            const payload = JSON.stringify({action:'handleScan', code:String(code||'')});
            log('SEND','auto sendData ' + payload);
            TG.sendData?.(payload);
            // Нічого не приховуємо: нижня кнопка лишається доступною
            // За потреби — автозакриття:
            // autoCloseTimer = setTimeout(()=>{ try{ TG.close?.(); }catch(_){} }, 1200);
          }, 200);
        } else {
          // Не WebApp — просто оновили інпут і статус; користувач натисне «Надіслати» і отримає копіювання
          status('Скановано. Відкрийте через кнопку в боті для автонадсилання або натисніть «Надіслати» для копіювання.');
        }

      }catch(e){
        log('SEND','err '+(e.message||e));
        status('Помилка надсилання');
      }
    }

    // Камера
    const video=$('#video');
    const canvas=$('#canvas');
    const ctx=canvas.getContext('2d',{willReadFrequently:true});

    async function enumerateCams(){
      try{
        const dev=await navigator.mediaDevices.enumerateDevices();
        const vids=dev.filter(d=>d.kind==='videoinput');
        log('DEV', JSON.stringify(vids.map(v=>({label:v.label,id:v.deviceId})))); 
        return vids;
      }catch(e){ log('DEV','err '+(e.message||e)); return []; }
    }
    async function chooseBackCamera(base){
      const vids=await enumerateCams();
      const back=vids.find(d=>/back|rear|зад|environment/i.test(d.label));
      if(back){ log('CAM','use back '+back.label); return { ...base, video: { ...base.video, deviceId: { exact: back.deviceId } } }; }
      log('CAM','fallback default camera'); return base;
    }
    async function startCamera(){
      if(!navigator.mediaDevices?.getUserMedia){ status('Камера не підтримується'); return null; }
      video.muted=true; video.setAttribute('muted','');
      let constraints={ audio:false, video:{ facingMode:{ideal:'environment'}, width:{ideal:1920}, height:{ideal:1080}, frameRate:{ideal:30,max:60}, advanced:[{focusMode:'continuous'}] } };
      try{
        constraints=await chooseBackCamera(constraints);
        log('GUM','constraints '+JSON.stringify(constraints.video||{}));
        const stream=await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject=stream; await video.play(); status('Камера запущена — наведіть на код'); return stream;
      }catch(e){
        log('GUM','primary fail '+(e.name||e));
        try{
          const s=await navigator.mediaDevices.getUserMedia({video:true,audio:false});
          video.srcObject=s; await video.play(); status('Камера (fallback) — скануйте'); return s;
        }catch(e2){ status('Камеру не вдалося запустити: '+(e2.name||e2)); throw e2; }
      }
    }

    // Нативний детектор → ZXing (core)
    let detector=null;
    async function setupNative(){
      if(!('BarcodeDetector' in window)) return false;
      try{
        const sup = (await window.BarcodeDetector.getSupportedFormats?.())||[];
        const formats = BARCODE_FORMATS_NATIVE.filter(f=>sup.includes(f));
        log('Native formats', JSON.stringify(formats));
        if(!formats.length) return false;
        detector = new window.BarcodeDetector({formats});
        return true;
      }catch(e){ log('Native','unavailable '+(e.message||e)); return false; }
    }

    function getRoiRect(vw, vh){
      const rw=Math.floor(vw*0.86), rh=Math.floor(vh*0.40);
      const rx=Math.floor((vw-rw)/2), ry=Math.floor((vh-rh)/2);
      return {rx,ry,rw,rh};
    }
    function grabRoi(){
      const vw=video.videoWidth, vh=video.videoHeight; if(!vw||!vh) return null;
      const {rx,ry,rw,rh}=getRoiRect(vw,vh);
      canvas.width=rw; canvas.height=rh;
      ctx.drawImage(video, rx, ry, rw, rh, 0, 0, rw, rh);
      const imageData=ctx.getImageData(0,0,rw,rh);
      return {imageData, rw, rh};
    }
    function tryDecodeZX(){
      try{
        const ZX = window.ZXing;
        if(!ZX){ log('ZX','not loaded'); return null; }
        const frame=grabRoi(); if(!frame) return null;
        const {imageData, rw, rh}=frame;
        const luminances = new Uint8ClampedArray(rw*rh);
        for(let i=0,j=0; i<imageData.data.length; i+=4, j++) luminances[j]=imageData.data[i];
        const src = new ZX.RGBLuminanceSource(luminances, rw, rh);
        const bitmap = new ZX.BinaryBitmap(new ZX.HybridBinarizer(src));
        const reader = new ZX.MultiFormatReader();
        const hints = new Map(); hints.set(ZX.DecodeHintType.TRY_HARDER, true);
        reader.setHints?.(hints);
        const result = reader.decode(bitmap);
        if(result && result.getText){ return String(result.getText()).trim(); }
        return null;
      }catch(e){ return null; }
    }

    async function loopScanNative(){
      try{
        const codes=await detector.detect(video);
        if(codes?.length){
          const val=(codes[0].rawValue||'').trim();
          log('NATIVE','hit '+val);
          if(val) return sendToBotAuto(val);
        }
      }catch(e){ log('NATIVE','err '+(e.message||e)); }
      requestAnimationFrame(loopScanNative);
    }
    function loopScanZXcore(){
      const code = tryDecodeZX();
      if(code){ log('ZX','hit '+code); return sendToBotAuto(code); }
      setTimeout(loopScanZXcore, SCAN_INTERVAL_MS);
    }

    (async()=>{
      try{
        window.Telegram?.WebApp?.ready?.();
        TG = getTG();

        // Підказка середовища
        envHint.textContent = TG ? 'WebApp: так' : 'WebApp: ні';
        if (!TG) {
          log('HINT','Open via Telegram bot button for auto-send');
        }

        updateSendBtnState(); // кнопка відразу на екрані

        await startCamera();
        const okNative = await setupNative();
        if(okNative){ status('Скануйте… (native)'); requestAnimationFrame(loopScanNative); }
        else { status('Скануйте… (ZX core)'); loopScanZXcore(); }

      }catch(e){ status('Помилка запуску: '+(e?.name||e?.message||e)); }
    })();
  </script>
</body>
</html>
