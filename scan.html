<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>–°–∫–∞–Ω–µ—Ä —à—Ç—Ä–∏—Ö-–∫–æ–¥—É ‚Äî DEBUG</title>
  <style>
    :root { color-scheme: dark; }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:#000;color:#fff}
    header{padding:12px 16px;font-weight:600;background:#111}
    #video{width:100%;height:48vh;object-fit:cover;background:#000}
    #bar{display:flex;gap:8px;align-items:center;padding:10px 16px;background:#111;flex-wrap:wrap}
    button{padding:8px 12px;border-radius:10px;border:1px solid #444;background:#1b1b1b;color:#fff;cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    #status{padding:8px 16px;color:#ccc;background:#111}
    #cameraList{padding:6px 8px;border-radius:8px;border:1px solid #444;background:#1b1b1b;color:#fff}
    #log{height:32vh;overflow:auto;background:#0c0c0c;border-top:1px solid #333;font-family:ui-monospace,Consolas,monospace;padding:8px 12px;white-space:pre-wrap}
    .tag{display:inline-block;margin:2px 4px 2px 0;padding:2px 6px;border:1px solid #444;border-radius:999px;font-size:12px;background:#1b1b1b}
  </style>
</head>
<body>
  <header>–ù–∞–≤–µ–¥–∏ –∫–∞–º–µ—Ä—É –Ω–∞ —à—Ç—Ä–∏—Ö-–∫–æ–¥ (EAN-13 / Code-128) ‚Äî DEBUG</header>
  <video id="video" playsinline muted autoplay></video>

  <div id="bar">
    <button id="btnTorch" disabled>üî¶ Torch</button>
    <button id="btnRestart" disabled>üîÅ Restart</button>
    <select id="cameraList" title="–ü–µ—Ä–µ–º–∫–Ω—É—Ç–∏ –∫–∞–º–µ—Ä—É"></select>
    <button id="btnDownload">‚¨áÔ∏è Download logs</button>
    <span class="tag" id="tagFacing">facing: ?</span>
    <span class="tag" id="tagRes">res: ?</span>
    <span class="tag" id="tagTorch">torch: ?</span>
  </div>

  <div id="status">–ì–æ—Ç—É—é –∫–∞–º–µ—Ä—É‚Ä¶</div>
  <div id="log"></div>

  <script src="https://unpkg.com/@zxing/library@latest"></script>
  <script>
    // ---- Logger ----
    const logEl = document.getElementById('log');
    const logs = [];
    function log(...args){
      const line = args.map(v => {
        try { return typeof v === 'string' ? v : JSON.stringify(v); }
        catch { return String(v); }
      }).join(' ');
      const ts = new Date().toISOString().split('T')[1].replace('Z','');
      const msg = `[${ts}] ${line}`;
      logs.push(msg);
      console.log(msg);
      if (logEl) {
        logEl.textContent += msg + "\n";
        logEl.scrollTop = logEl.scrollHeight;
      }
    }
    window.onerror = (m, s, l, c, e) => log("ERROR", m, s, l, c, e && e.stack);

    const btnDownload = document.getElementById('btnDownload');
    btnDownload.addEventListener('click', ()=>{
      const blob = new Blob([logs.join("\n")], {type: "text/plain"});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `scanner_logs_${Date.now()}.txt`;
      a.click();
      URL.revokeObjectURL(a.href);
    });

    // ---- Telegram bridge ----
    const tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
    if (tg) { tg.expand(); log("TG WebApp detected"); }
    else { log("TG WebApp NOT detected ‚Äî –≤—ñ–¥–∫—Ä–∏–π —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É –≤ –±–æ—Ç—ñ"); }

    // ---- UI refs ----
    const video      = document.getElementById('video');
    const statusEl   = document.getElementById('status');
    const btnTorch   = document.getElementById('btnTorch');
    const btnRestart = document.getElementById('btnRestart');
    const cameraList = document.getElementById('cameraList');
    const tagFacing  = document.getElementById('tagFacing');
    const tagRes     = document.getElementById('tagRes');
    const tagTorch   = document.getElementById('tagTorch');

    function setStatus(t){ statusEl.textContent = t; log("STATUS:", t); }

    // ---- ZXing setup ----
    const hints = new Map();
    hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [
      ZXing.BarcodeFormat.CODE_128,
      ZXing.BarcodeFormat.EAN_13,
      ZXing.BarcodeFormat.EAN_8,
      ZXing.BarcodeFormat.UPC_A,
    ]);
    hints.set(ZXing.DecodeHintType.TRY_HARDER, true);
    const reader = new ZXing.BrowserMultiFormatReader(hints, 400);

    let currentTrack = null;
    let stopping = false;
    let chosenBackId = null;     // deviceId —Ç–∏–ª–æ–≤–æ—ó
    let watchdogTimer = null;    // —Å—Ç–∞–±—ñ–ª—ñ–∑–∞—Ç–æ—Ä

    async function stopAll(){
      try { await reader.reset(); } catch(e){ log("reader.reset error", e); }
      try { await video.pause(); } catch(e){ log("video.pause error", e); }
      if (currentTrack) {
        try { currentTrack.stop(); } catch(e){ log("track.stop error", e); }
      }
      btnTorch.disabled = true;
      if (watchdogTimer) { clearInterval(watchdogTimer); watchdogTimer = null; }
      log("Stopped all tracks");
    }

    function updateTrackTags(){
      try{
        const s = currentTrack?.getSettings?.() || {};
        tagFacing.textContent = `facing: ${s.facingMode || "?"}`;
        tagRes.textContent    = `res: ${s.width||"?"}x${s.height||"?"}`;
        const caps = currentTrack?.getCapabilities?.();
        tagTorch.textContent  = `torch: ${caps && 'torch' in caps ? 'yes' : 'no'}`;
      }catch(_){}
    }

    async function decodeWithDevice(deviceId){
      log("decodeWithDevice", deviceId);
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { deviceId: { exact: deviceId }, width: { ideal: 1280 }, height: { ideal: 720 } },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
      currentTrack = stream.getVideoTracks()[0];
      updateTrackTags();

      // Torch availability
      try {
        const caps = currentTrack?.getCapabilities?.();
        btnTorch.disabled = !(caps && 'torch' in caps);
      } catch(e){ log("caps error", e); }

      await reader.decodeFromVideoDevice(deviceId, video, (result, err) => {
        if (stopping) return;
        if (result){
          stopping = true;
          const code = String(result.getText()||"").trim();
          setStatus(`–ó—á–∏—Ç–∞–Ω–æ: ${code}. –í—ñ–¥–ø—Ä–∞–≤–ª—è—é –≤ –±–æ—Ç‚Ä¶`);
          try { navigator.vibrate && navigator.vibrate(40); } catch(_){}
          stopAll().finally(()=> { if (tg && tg.sendData) tg.sendData(code); });
        }
      });

      // ---- Watchdog: –∫–æ–∂–Ω—É —Å–µ–∫—É–Ω–¥—É –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –Ω–µ ‚Äú–ø–µ—Ä–µ–∫–∏–Ω—É–ª–æ‚Äù ----
      watchdogTimer = setInterval(async ()=>{
        try {
          const s = currentTrack?.getSettings?.() || {};
          // —è–∫—â–æ facingMode —Å—Ç–∞–≤ "user" –∞–±–æ –∑–º—ñ–Ω–∏–≤—Å—è track.label ‚Äî –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ—Å—å –Ω–∞ chosenBackId
          if ((s.facingMode === "user") && chosenBackId) {
            log("WATCHDOG detected switch to FRONT; re-binding back deviceId", chosenBackId, s);
            stopping = true;
            await stopAll();
            stopping = false;
            await decodeWithDevice(chosenBackId);
          }
        } catch(e){ log("watchdog error", e); }
      }, 1000);
    }

    async function enumerateCams(){
      const devs = (await navigator.mediaDevices.enumerateDevices()).filter(d => d.kind === "videoinput");
      log("Devices:", devs.map(d => ({label:d.label, deviceId:d.deviceId, groupId:d.groupId})));
      // Populate select
      cameraList.innerHTML = devs.map((d,i)=>{
        const lbl = d.label || `–ö–∞–º–µ—Ä–∞ ${i+1}`;
        const hint = /back|rear|environment/i.test(lbl) ? " (—Ç–∏–ª–æ–≤–∞)" : "";
        return `<option value="${d.deviceId}">${lbl}${hint}</option>`;
      }).join("");
      cameraList.style.display = devs.length > 1 ? "block" : "none";

      // Heuristics for back camera
      let back = devs.find(d => /back|rear|environment/i.test(d.label));
      if (!back && devs.length) back = devs[devs.length - 1]; // fallback
      chosenBackId = back ? back.deviceId : (devs[0] && devs[0].deviceId);
      log("Chosen back deviceId:", chosenBackId, "label:", back && back.label);
      return {devs, backId: chosenBackId};
    }

    async function startCamera(){
      setStatus("–ó–∞–ø–∏—Ç—É—é –¥–æ–∑–≤—ñ–ª –¥–æ –∫–∞–º–µ—Ä–∏‚Ä¶");
      btnRestart.disabled = true; btnTorch.disabled = true;
      try {
        // 1) –õ–∏—à–µ permission ‚Äî —â–æ–± –∑ º—è–≤–∏–ª–∏—Å—å labels (–Ω—ñ—á–æ–≥–æ –Ω–µ –ø–æ–∫–∞–∑—É—î–º–æ)
        let tmp = null;
        try {
          tmp = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: "environment" } }, audio: false });
        } catch {
          tmp = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        }
        tmp.getTracks().forEach(t => t.stop());
        log("Permission granted");

        // 2) Enumerate + choose back
        const { backId } = await enumerateCams();
        if (!backId) throw new Error("–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤—ñ–¥–µ–æ–∫–∞–º–µ—Ä–∏");

        // 3) Start decoding with BACK only
        await decodeWithDevice(backId);

        btnRestart.disabled = false;
        setStatus("–ù–∞–≤–æ–¥—å —à—Ç—Ä–∏—Ö-–∫–æ–¥ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ, –±–µ–∑ –±–ª–∏–∫—ñ–≤.");
      } catch (e) {
        log("startCamera error", e && e.message);
        setStatus("–ü–æ–º–∏–ª–∫–∞ –¥–æ—Å—Ç—É–ø—É –¥–æ –∫–∞–º–µ—Ä–∏. –ü–µ—Ä–µ–≤—ñ—Ä HTTPS/–¥–æ–∑–≤—ñ–ª.");
      }
    }

    // UI events
    btnTorch.addEventListener('click', async () => {
      try{
        const caps = currentTrack?.getCapabilities?.();
        if (caps && 'torch' in caps){
          const set = currentTrack.getSettings();
          await currentTrack.applyConstraints({ advanced: [{ torch: !set.torch }] });
          log("Torch toggled");
        } else {
          log("Torch not supported");
        }
      }catch(e){ log("Torch error", e); }
    });

    btnRestart.addEventListener('click', async () => {
      stopping = true;
      await stopAll();
      stopping = false;
      await startCamera();
    });

    cameraList.addEventListener('change', async () => {
      const id = cameraList.value;
      if (!id) return;
      log("Manual camera switch to", id);
      chosenBackId = id; // —Ç–µ–ø–µ—Ä —Ü–µ ‚Äî ‚Äú—Ü—ñ–ª—å–æ–≤–∏–π‚Äù –ø—Ä–∏—Å—Ç—Ä—ñ–π –¥–ª—è watchdog
      stopping = true;
      await stopAll();
      stopping = false;
      await decodeWithDevice(id);
    });

    // Start
    (async ()=>{
      // –î–ª—è –¥–∏—Ñ–µ—Ä–µ–Ω—Ü—ñ–∞—Ü—ñ—ó –ø–ª–∞—Ç—Ñ–æ—Ä–º–∏ –≤ –ª–æ–≥–∞—Ö
      log("UA:", navigator.userAgent);
      await startCamera();
    })();
  </script>
</body>
</html>
